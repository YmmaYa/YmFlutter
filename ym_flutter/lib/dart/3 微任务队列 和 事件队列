
1. 事件队列（Event Queue）是否都是异步的？
    ✅ 答：是异步的。事件队列中的任务一定是异步执行的，包括：
        ❄️ I/O 操作（文件读写、网络请求）
        ❄️ 定时器（Timer、Future.delayed）
        ❄️ 用户交互事件（如按钮点击）
        ❄️ 默认的 Future 回调（通过 Future(() => {}) 添加的任务）
    （1）特点：
        ❄️ 任务在同步代码执行完毕后，由事件循环按顺序处理。
        ❄️ 即使代码中直接调用 Future，其回调也会被放入事件队列，不会阻塞当前同步代码。

2. 微任务队列（Microtask Queue）是否在主线程？
    ✅ 是的。微任务队列和事件队列都运行在同一个主线程（Isolate）中。
    （1）关键区别：
        ❄️ 微任务队列的优先级高于事件队列。
        ❄️ 微任务会在当前同步代码执行完毕后立即执行，而事件队列的任务需要等待微任务清空后才会处理。

3. 微任务代码是同步的吗？
    ✅ 不是同步的，但表现类似同步代码的执行顺序。
    （1）微任务虽然是异步调度，但它的执行时机位于同步代码和事件队列任务之间，因此看起来像是“同步”执行。实际上：
        ❄️ 异步性：通过 scheduleMicrotask 或 Future.microtask 调度的代码仍然是异步的，不会阻塞当前同步代码。
        ❄️ 即时性：微任务会在当前同步代码执行完毕后立即执行，无需等待其他事件队列任务。

4. 关键总结
    特性	            微任务队列	                            事件队列
    执行线程	        主线程（Isolate）	                        主线程（Isolate）
    调度方式	        scheduleMicrotask/Future.microtask	    Future/Timer/I/O 回调
    执行时机	        同步代码结束后立即执行	                    微任务队列清空后按顺序执行
    是否阻塞同步代码	否（异步调度）	                        否（异步调度）
    典型用途	        状态更新、高优先级回调	                    I/O、定时任务、用户交互事件

5. 常见误区澄清
    误区❌：微任务是同步的。
    正解✅：微任务是异步的，只是执行时机紧接在同步代码之后，看起来像同步。
    误区❌：事件队列和微任务队列属于不同线程。
    正解✅：两者都在同一主线程中，由事件循环调度。
    误区❌：Future 一定是事件队列任务。
    正解✅：默认是事件队列，但通过 Future.microtask 可指定为微任务。

6. 性能注意事项
        ❄️ 避免微任务滥用：过多的微任务会阻塞事件队列，导致 UI 卡顿（如动画延迟）。
        ❄️ 耗时操作：无论是微任务还是事件任务，都不应包含耗时计算（应交给 Isolate）。