
事件饥饿（Event Starvation）

定义：在 Dart 的单线程事件循环模型中，如果 微任务队列（Microtask Queue） 持续被高优先级任务填满，
     导致 事件队列（Event Queue） 中的任务（如 I/O、用户交互、渲染等）长时间得不到执行，这种现象称为 事件饥饿。

1. 为什么会发生事件饥饿？
    Dart 的事件循环优先级：
        （1）同步代码（立即执行）
        （2）微任务队列（全部清空）
        （3）事件队列（每次只处理一个任务）
    如果微任务不断产生新微任务（比如递归调用 scheduleMicrotask），事件队列的任务就会一直被延迟，导致：
        （1）UI 卡顿（无法响应点击、动画掉帧）
        （2）I/O 延迟（网络请求、文件读写变慢）
        （3）定时器不准确（Timer 或 Future.delay 延迟）

    ⚠️ 在 Flutter 中，事件饥饿会导致：
       （1）UI 卡顿：setState 触发的重建被延迟。
       （2）手势无响应：点击/滑动事件堆积在事件队列。
       （3）动画掉帧：渲染任务无法及时执行。
       （4）I/O 延迟（网络请求、文件读写变慢）
       （5）定时器不准确（Timer 或 Future.delay 延迟）
    调试方法：
        ✅ 使用 Flutter DevTools 查看帧渲染时间。
        ✅ 检查是否有过多的 scheduleMicrotask 调用。

2. 如何避免事件饥饿？
（1）控制微任务的使用场景：微任务仅适用于 需要立即执行的内部逻辑，例如：
    ❄️ 状态管理（如 Provider 通知监听者）
    ❄️ Future 的完成回调（then/catchError）
    ❄️ 确保某些代码在 同步代码结束后但事件队列之前 执行
（2）避免在微任务中递归/死循环

（3）拆分耗时任务
        如果必须处理大量计算：
            ❄️ 用 Future 分批次执行（让事件队列有机会处理其他任务）
                    void heavyComputation() {
                      int i = 0;
                      void chunk() {
                        for (int j = 0; j < 1000; j++) {
                          i++; // 模拟计算
                        }
                        if (i < 100000) {
                          Future(chunk); // 每次处理完一批后，让出事件循环
                        }
                      }
                      chunk();
                    }
            ❄️ 移交给 Isolate（真并行计算）